{"ast":null,"code":"/**\n * state를 관리(변경)하는 함수들만 별도로 분리, 보관하는 함수 => Reducer\n * dispatch가 호출되면 reducer가 호출된다.\n *\n * : context 없이 reducer 만으로도 state 통합 관리가 가능.\n * : 보통 context + reducer의 조합으로 사용한다.\n *  Why? reducer만으로 state를 관리할 경우, 복잡해질 가능성이 높다.\n *  context는 state를 공급만 해준다. reducer만 각각의 state와 관련된 함수들만 모아서 관리.\n * @param {*} state : Reducer가 관리하는 state\n * @param {*} action : state를 변경시킬 정보들(dispatcher에 의해 전달된다.) => {type, payload}\n */\nexport const todoReducers = (state, action) => {\n  /*\n      todo 완료 처리할 경우의 action\n      {type: \"DONE\", payload: todo의 id}\n    */\n  const type = action.type; // action에서 type을 꺼내고\n\n  if (type === \"DONE\") {\n    // todo를 완료 / 미완료 토글하는 코드.\n    // 파라미터로 들어온 state는 어떻게 변경 해야 하나?\n    // 새로운 state를 반환시킨다. (더 이상 set~~하지 않음)\n    return state.map(todo => {\n      if (todo.id === action.payload.id) {\n        todo.isDone = action.payload.isChecked; // 체크하면 바꿔서 넣어라.\n      }\n      return todo; // 여기서 반환하는 대상은 Map임. 그러면 state를 새로 만드는 것(메모리 주소가 바뀐다.)\n    });\n  } else if (type === \"ADD\") {\n    /*\n     * (아래처럼 들어올 것이라고 가정)\n     * todo를 추가하는 경우의 action\n     * { type: \"ADD\", payload: {task: \"sample task\", dueDate: \"2024-11-20\"}}\n     */\n    return [{\n      id: state.length,\n      isDone: false,\n      task: action.payload.task,\n      dueDate: action.payload.dueDate\n    }, ...state];\n  } // 더 할게 있으면 여기서 또 else if 하면 됨\n\n  // action type이 어디에도 해당하지 않을 때에는, 원래의 state를 그대로 반환시킨다. -> 이렇게 안하면 아무 값도 가지지 않음(void)\n  return state;\n};","map":{"version":3,"names":["todoReducers","state","action","type","map","todo","id","payload","isDone","isChecked","length","task","dueDate"],"sources":["/Users/moomin/Front-end/react/todoappReducer/src/components/todo/reducers/todoReducer.js"],"sourcesContent":["/**\n * state를 관리(변경)하는 함수들만 별도로 분리, 보관하는 함수 => Reducer\n * dispatch가 호출되면 reducer가 호출된다.\n *\n * : context 없이 reducer 만으로도 state 통합 관리가 가능.\n * : 보통 context + reducer의 조합으로 사용한다.\n *  Why? reducer만으로 state를 관리할 경우, 복잡해질 가능성이 높다.\n *  context는 state를 공급만 해준다. reducer만 각각의 state와 관련된 함수들만 모아서 관리.\n * @param {*} state : Reducer가 관리하는 state\n * @param {*} action : state를 변경시킬 정보들(dispatcher에 의해 전달된다.) => {type, payload}\n */\nexport const todoReducers = (state, action) => {\n  /*\n      todo 완료 처리할 경우의 action\n      {type: \"DONE\", payload: todo의 id}\n    */\n  const type = action.type; // action에서 type을 꺼내고\n\n  if (type === \"DONE\") {\n    // todo를 완료 / 미완료 토글하는 코드.\n    // 파라미터로 들어온 state는 어떻게 변경 해야 하나?\n    // 새로운 state를 반환시킨다. (더 이상 set~~하지 않음)\n    return state.map((todo) => {\n      if (todo.id === action.payload.id) {\n        todo.isDone = action.payload.isChecked; // 체크하면 바꿔서 넣어라.\n      }\n      return todo; // 여기서 반환하는 대상은 Map임. 그러면 state를 새로 만드는 것(메모리 주소가 바뀐다.)\n    });\n  } else if (type === \"ADD\") {\n    /*\n     * (아래처럼 들어올 것이라고 가정)\n     * todo를 추가하는 경우의 action\n     * { type: \"ADD\", payload: {task: \"sample task\", dueDate: \"2024-11-20\"}}\n     */\n    return [\n      {\n        id: state.length,\n        isDone: false,\n        task: action.payload.task,\n        dueDate: action.payload.dueDate,\n      },\n      ...state,\n    ];\n  } // 더 할게 있으면 여기서 또 else if 하면 됨\n\n  // action type이 어디에도 해당하지 않을 때에는, 원래의 state를 그대로 반환시킨다. -> 이렇게 안하면 아무 값도 가지지 않음(void)\n  return state;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,YAAY,GAAGA,CAACC,KAAK,EAAEC,MAAM,KAAK;EAC7C;AACF;AACA;AACA;EACE,MAAMC,IAAI,GAAGD,MAAM,CAACC,IAAI,CAAC,CAAC;;EAE1B,IAAIA,IAAI,KAAK,MAAM,EAAE;IACnB;IACA;IACA;IACA,OAAOF,KAAK,CAACG,GAAG,CAAEC,IAAI,IAAK;MACzB,IAAIA,IAAI,CAACC,EAAE,KAAKJ,MAAM,CAACK,OAAO,CAACD,EAAE,EAAE;QACjCD,IAAI,CAACG,MAAM,GAAGN,MAAM,CAACK,OAAO,CAACE,SAAS,CAAC,CAAC;MAC1C;MACA,OAAOJ,IAAI,CAAC,CAAC;IACf,CAAC,CAAC;EACJ,CAAC,MAAM,IAAIF,IAAI,KAAK,KAAK,EAAE;IACzB;AACJ;AACA;AACA;AACA;IACI,OAAO,CACL;MACEG,EAAE,EAAEL,KAAK,CAACS,MAAM;MAChBF,MAAM,EAAE,KAAK;MACbG,IAAI,EAAET,MAAM,CAACK,OAAO,CAACI,IAAI;MACzBC,OAAO,EAAEV,MAAM,CAACK,OAAO,CAACK;IAC1B,CAAC,EACD,GAAGX,KAAK,CACT;EACH,CAAC,CAAC;;EAEF;EACA,OAAOA,KAAK;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}